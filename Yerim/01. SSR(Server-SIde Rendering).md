
# SPA(Single Page Application)
> ✅ 하나의 페이지로 이루어진 홈페이지

- **CSR(Client-Side Rendering)**
에 적합
- 웹 애플리케이션에서 필요한 정적 리소스를 최초 한 번에 다운로드
- 그 후 새로운 요청이 있울 때 서버에서 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성

### 장점
- UX 향상 : 전체 페이지 깜빡임으로 인한 불편함 감소
- 성능 : 필요한 부분만 부분적으로 로딩
- 모바일 친화적(Mobile First 전략에 부합)
- SPA 애플리케이션은 서버에 정적 리소스를 최초에 한 번 요정, 받은 데이터는 전부 저장
  - 해당 데이터는 오프라인에서도 사용 가능 → 때문에 SPA에서는 로컬 데이터를 효과적으로 캐시 할 수 있음
    
### 단점

- 초기 구동 속도 : 모든 리소스를 최초 접근 시 한번에 다운로드
- SEO 취약
  - html 파일 하나를 받아와서 작동
  - 각각 페이지에 대한 정보를 담기 힘듦
  - js로 구축되므로 js를 읽지 못하는 검색엔진에 대해 크롤링이 되지 않음
- XSS 공격에 취약
  - XSS
    > ✅ Cross-Site Scripting : 악의적인 사용자가 웹 페이지에 악성 스크립트를 삽입하여 해당 스크립트가 다른 사용자들의 브라우저에서 실행되도록 하는 공격
  - SSR에서는 사용자 정보를 서버에서 세션으로 관리하지만 <br> CSR에서는 클라이언트 측의 쿠키, localstorage 말고는 사용자 정보를 저장할 공간이 부족
  - 주로 클라이언트 측에서 실행되는 악성 스크립트로 이루어지기 때문에 쿠키나 로컬스토리지 악용 가능성 존재

# CSR(Client-Side Rendering)
> ✅ 클라이언트에서 사용자에게 보여줄 페이지를 렌더링하여 보여주는 방식

- SSR보다 초기 전송되는 페이지의 속도는 빠르지만, 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성 → 전체적인 페이지 완료 시점은 SSR보다 느림
- 동작방식
  1. user → website 요청
  2. CDN이 html 파일과 js로 접근할 수 있는 링크르 클라이언트로 보냄
  3. 클라이언트는 html, js를 다운받음 → 이때 SSR과 달리 유저는 아무것도 볼 수 없다
  4. 클라이언트는 js 다운로드
  5. 다운이 완료된 js 실행, 데이터를 위한 api 호출 → 이떄 유저는 placeholder를 보게됨
  6. 서버가 api로부터의 요청에 응답
  7. api로부터 받아온 data를 placeholder 자리에 넣어준다

# MPA(Multi Page Application)
> ✅ 여러개의 페이지로 이루어진 홈페이지

- **SSR(Server-Side Rendering)**
에 적합
- 새로운 페이지를 요청할 때마다 서버에 렌더링된 정적 리소스 다룬오드
- 페이지 이동, 새로고침 시 전체 페이지 다시 렌더링

### 장점
- SEO 친화적
  - 브라우저에서 js 코드가 동작하기 전에 완성된 형태의 템플릿(HTML에 데이터가 삽입된 상태)를 서버로 부터 전달받음
  - 검색 로봇이 페이지를 크롤링하기에 매우 적합
- 첫 로딩 속도 빠름
  - 서버에서 이미 로딩해서 가져옴
  - 클라이언트가 js 파일을 모두 다운로드하고 적용하기 전까지는 기능이 동작하지 않음

### 단점
- UX 약화 : 페이지 이동 시 깜빡임
- 페이지 이동 시 속도 저하 : 새로운 페이지 이동 시 전체 페이지 다시 렌더링

# SSR(Servier-Side Rendering)
> ✅ 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식

- 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있음
- CSR보다 페이지 구성 속도는 늦어지지만, 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라짐
- SEO 설정 용이
- 동작방식
  1. user → website 요청
  2. server는 ‘ready to render’, 즉 즉시 렌더링 가능한 html 파일 생성
  3. 클라이언트에 전달된 순간 이미 렌더링 준비 → html 즉시 렌더링, 그러나 사이트 자체는 조작 불가(js 읽히기 전)
  4. 클라이언트가 js 다운로드
  5. 다운 받는 사이 유저는 컨텐츠를 볼 수 있지만, 조작 불가 → 이때의 사용자 조작을 기억
  6. 브라우저가 js 프레임워크 실행
  7. js까지 성공적으로 컴파일 → 기억하고 있던 사용자 조작 실행, 웹 페이지 상호작용 가능

# 나의 궁금증
- SPA, CSR, MPA, SSR의 특징과 차이는 다 이해함
- 네이버 D2 블로그 읽으면서 궁금한 점 → SSR를 사용함으로써 어떻게 프론트와 백이 분리되었나.. 잘 이해가 안됨
- 내가 이해한 대로라면 SSR → 서버에서 데이터까지 포함해서 다 내려준다는건데.. 그럼 api 호출에 대한 필요성이 없어지는 것 아닌가?
- SEO도 향상시키고, SPA의 장점도 가져가기 위해서 SSR, CSR 둘다 사용하는데, 이때 프론트가 next.js와 같은 프레임워크를 사용해서 SSR를 담당하게 되면서, 백엔드는 단순 api 개발에만 집중하면 된다는 이야기인가? → 그래서 분리되었다. 라고 이야기하는건가?

# 참고 문서

[[ 기술 스터디 ] SSR과 CSR의 차이](https://velog.io/@vagabondms/기술-스터디-SSR과-CSR의-차이)

[[간단정리] CSR vs SSR 특징 및 차이](https://hahahoho5915.tistory.com/52)

[CSR과 SSR의 차이점](https://story.pxd.co.kr/1662)

[어서 와, SSR은 처음이지? - 도입 편](https://d2.naver.com/helloworld/7804182)

[[React] 네이버 블로그의 Node.js기반 SSR 전환, CSR과 SSR방식을 자세하게 살펴보기](https://velog.io/@sunaaank/React-deep-dive)
